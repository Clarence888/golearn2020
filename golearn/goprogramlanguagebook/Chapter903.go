package main
//使用共享变量实现并发

/*
竞态:多个goroutine按照某些交错顺序执行时程序无法给出正确结果

并发安全：一个能在串行程序中正确工作的函数， 如果他在并发调用（没有额外同步机制 从两个或者多个同时调用这个函数）时仍然可以正确工作

函数并发调用时不工作的原因：死锁 活锁 资源耗尽

数据竞态：发生于两个goroutine并发读写同一个变量 并且至少其中一个是写入

如何避免数据静态：三种方法
1.不要修改变量 在创建其他goroutine之前完整的数据来初始化变量 比如map

2.避免从多个goroutine访问同一个变量
（必须通过使用通道向受限goroutine发送查询请求或者更新变量）-->这个goroutine叫做 该变量的监控goroutine  （monitor goroutine）
引申：不要通过共享内存来通信，而要通过通信来共享内存。

3.允许多个goroutine访问同一个变量 但是在同一时间 只有一个goroutine可以访问

*/

//互斥锁 sync.Mutex

//可以用一个容量为1的通道保证同一时间最多有一个goroutine能访问共享变量
//一个计数上限为1 的信号量  称为二进制信号量 binary semaphore
var (
	sema
)